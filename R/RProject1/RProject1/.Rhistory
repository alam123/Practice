#CRR #A[n+1] = A[n] * exp (mu * dt + sigma * sqrt(dt) * x[n]) simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     p <- 0.5     #q <- 0.5 * (1 + (r - mu) / sigma * sqrt(dt));     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xp <- 2 * (u < p) - 1;     xq <- 2 * (u < q) - 1;     cumxp <- cumsum(xp);     cumxq <- cumsum(xq);     Sp <- rep(0, N)     Sq <- rep(0, N)     Sp[1] <- 1;     Sq[1] <- 1;     for (i in 2:N) {         Sp[i] <- Sp[1] * exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxp[i - 1]);         Sq[i] <- Sq[1] * exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(list(Sp = Sp, Sq = Sq)); } T = 1; N = 1000; dt = T / N; sigma <- 0.5 mu <- 0.1 r <- 0.01 # generate many paths M <- 5000; SpT <- rep(0, M); SqT = rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SpT[i] = res$Sp[N];     SqT[i] = res$Sq[N]; } par(mfrow = c(2, 1)) p1 <- hist(SpT, breaks = seq(0, 10, 0.1)) p2 <- hist(SqT, breaks = seq(0, 10, 0.1)) plot(p1, col = "green") # first histogram plot(p2, col = "red") # second plot(p1, col = "green", add = T) # second mean(SpT) exp(mu) mean(SqT) exp(r)
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     #res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     #res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     #res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     #res <- simCRR(T, N, mu, sigma, r);     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     #res <- simCRR(T, N, mu, sigma, r);     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
0.5 * (1 + ((r - mu) / sigma) * sqrt(dt))
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     #res <- simCRR(T, N, mu, sigma, r);     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # generate many paths M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     #res <- simCRR(T, N, mu, sigma, r);     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 1)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
#CRR #A[n+1] = A[n] * exp (mu * dt + sigma * sqrt(dt) * x[n]) simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     p <- 0.5     #q <- 0.5 * (1 + (r - mu) / sigma * sqrt(dt));     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xp <- 2 * (u < p) - 1;     xq <- 2 * (u < q) - 1;     cumxp <- cumsum(xp);     cumxq <- cumsum(xq);     Sp <- rep(0, N)     Sq <- rep(0, N)     Sp[1] <- 1;     Sq[1] <- 1;     for (i in 2:N) {         Sp[i] <- Sp[1] * exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxp[i - 1]);         Sq[i] <- Sq[1] * exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(list(Sp = Sp, Sq = Sq)); } T = 1; N = 1000; dt = T / N; sigma <- 0.5 mu <- 0.1 r <- 0.01 # generate many paths M <- 5000; SpT <- rep(0, M); SqT = rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SpT[i] = res$Sp[N];     SqT[i] = res$Sq[N]; } par(mfrow = c(2, 1)) p1 <- hist(SpT, breaks = seq(0, 10, 0.1)) p2 <- hist(SqT, breaks = seq(0, 10, 0.1)) plot(p1, col = "green") # first histogram plot(p2, col = "red") # second plot(p1, col = "green", add = T) # second mean(SpT) exp(mu) mean(SqT) exp(r)
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # CRR M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 2)) plot(SqT, col = "green", Position) plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple") M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # CRR M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 2)) plot(SqT, col = "green", Position) plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple") M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # CRR M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 2)) plot(SqT, col = "green", Position) plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
hist(VT, col = "blue")
plot(VT, col = "red")
plot(SqT, col = "green", Position)
simCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - 0.5 * sigma ^ 2) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- Sq[1] * exp(sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } simAltCRR <- function(T, N, mu, sigma, r) {     # tim step size     dt <- T / N;     # branching probabilities     q <- 0.5 * (1 + ((r - mu) / sigma) * sqrt(dt));     # generate Bernoullis     u <- runif(N);     xq <- 2 * (u < q) - 1;     cumxq <- cumsum(xq);     Sq <- rep(0, N)     Sq[1] <- 1;     for (i in 2:N) {         Sq[i] <- exp((mu - 0.5 * sigma ^ 2) * dt * i + sigma * sqrt(dt) * cumxq[i - 1]);     }     return(Sq = Sq); } T = 1.0; N = 100; dt = T / N; sigma = 1.5 mu = 0.1 r = 0.01 S0 = 100 K = 20 #closed form solution #V0 = S0 * phi(d1) - K * exp(-r*T) * phi(d2)) #d1 = (ln(S0/K) + (r + 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) #d2 = (ln(S0/K) + (r - 0.5*sigma^2)(T2-T1))/(sigma*(sqrt(T2-T1)) d1 <- (log(S0 / K) + (r + 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) d2 <- (log(S0 / K) + (r - 0.5 * sigma ^ 2) * T) / (sigma * (sqrt(T))) V0C <- S0 * pnorm(d1) - K * exp(-r * T) * pnorm(d2) sprintf("d1=%f d2=%f V0=%f", d1, d2, V0C) # CRR M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) par(mfrow = c(4, 2)) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple") # Alt CRR M <- 100; SqT <- rep(0, M); VT <- rep(0, M); for (i in 1:M) {     res <- simAltCRR(T, N, mu, sigma, r);     SqT[i] <- S0 * res[N];     VT[i] = max(0, S0 * res[N] - K) } V0M <- exp(-r * T) * mean(VT) sprintf("V0M=%f", V0M) plot(SqT, col = "green") plot(VT, col = "red") hist(VT, col = "blue") hist(S0 * res, col = "purple")
rm(list = ls(all = TRUE))
graphics.off()
rm(list = ls(all = TRUE)) graphics.off() # some general parameters set.seed(1) # seed for random number generation dt = 1 # length of each time interval T = 250 # time period t = seq(1, T, by = dt) # vector containing time steps r = NULL # vector of instantaneous short rate r[1] = 0.03 # initial value of the short rate dv = NULL # random increment, depending on # the Wiener Process and volatility SFEsimVasicek = function(a, b, sigma) {     # Vasicek Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Vasicek Model") } SFEsimCIR = function(a, b, sigma) {     # Cox-Ingersoll-Ross Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * sqrt(r[i - 1]) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Cox-Ingersoll-Ross Model") } delta = function(t) {     # Deterministic function of Time     delta = 0.0000644 * t     return(delta) } SFEsimHullWhite = function(a, sigma) {     # Hull-White Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + (delta(t = i - 1) - a * r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Hull White Model") } SFEsimHoLee = function(sigma) {     # Ho-Lee Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + delta(i - 1) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Ho Lee Model") } SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009) SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055) SFEsimHullWhite(a = 0.161, sigma = 0.009) SFEsimHoLee(sigma = 0.009)
SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009)
SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055)
SFEsimHullWhite(a = 0.161, sigma = 0.009)
SFEsimHoLee(sigma = 0.009)
rm(list = ls(all = TRUE)) graphics.off() # some general parameters set.seed(1) # seed for random number generation dt = 1 # length of each time interval T = 250 # time period t = seq(1, T, by = dt) # vector containing time steps r = NULL # vector of instantaneous short rate r[1] = 0.03 # initial value of the short rate dv = NULL # random increment, depending on # the Wiener Process and volatility SFEsimVasicek = function(a, b, sigma) {     # Vasicek Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Vasicek Model") } SFEsimCIR = function(a, b, sigma) {     # Cox-Ingersoll-Ross Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * sqrt(r[i - 1]) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Cox-Ingersoll-Ross Model") } delta = function(t) {     # Deterministic function of Time     delta = 0.0000644 * t     return(delta) } SFEsimHullWhite = function(a, sigma) {     # Hull-White Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + (delta(t = i - 1) - a * r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Hull White Model") } SFEsimHoLee = function(sigma) {     # Ho-Lee Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + delta(i - 1) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Ho Lee Model") } par(mfrow = c(2, 2)) SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009) SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055) SFEsimHullWhite(a = 0.161, sigma = 0.009) SFEsimHoLee(sigma = 0.009)
rm(list = ls(all = TRUE)) graphics.off() # some general parameters set.seed(1) # seed for random number generation dt = 1 # length of each time interval T = 250 # time period t = seq(1, T, by = dt) # vector containing time steps r = NULL # vector of instantaneous short rate r[1] = 0.03 # initial value of the short rate dv = NULL # random increment, depending on # the Wiener Process and volatility SFEsimVasicek = function(a, b, sigma) {     # Vasicek Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Vasicek Model") } SFEsimCIR = function(a, b, sigma) {     # Cox-Ingersoll-Ross Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * sqrt(r[i - 1]) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Cox-Ingersoll-Ross Model") } delta = function(t) {     # Deterministic function of Time     delta = 0.0000644 * t     return(delta) } SFEsimHullWhite = function(a, sigma) {     # Hull-White Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + (delta(t = i - 1) - a * r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Hull White Model") } SFEsimHoLee = function(sigma) {     # Ho-Lee Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + delta(i - 1) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Ho Lee Model") } par(mfrow = c(2, 2)) SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009) SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055) SFEsimHullWhite(a = 0.161, sigma = 0.009) SFEsimHoLee(sigma = 0.009)
rm(list = ls(all = TRUE)) graphics.off() # some general parameters set.seed(1) # seed for random number generation dt = 1 # length of each time interval T = 250 # time period t = seq(1, T, by = dt) # vector containing time steps r = NULL # vector of instantaneous short rate r[1] = 0.03 # initial value of the short rate dv = NULL # random increment, depending on # the Wiener Process and volatility SFEsimVasicek = function(a, b, sigma) {     # Vasicek Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Vasicek Model") } SFEsimCIR = function(a, b, sigma) {     # Cox-Ingersoll-Ross Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * sqrt(r[i - 1]) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Cox-Ingersoll-Ross Model") } delta = function(t) {     # Deterministic function of Time     delta = 0.0000644 * t     return(delta) } SFEsimHullWhite = function(a, sigma) {     # Hull-White Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + (delta(t = i - 1) - a * r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Hull White Model") } SFEsimHoLee = function(sigma) {     # Ho-Lee Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + delta(i - 1) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Ho Lee Model") } par(mfrow = c(2, 2)) SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009) SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055) SFEsimHullWhite(a = 0.161, sigma = 0.009) SFEsimHoLee(sigma = 0.009)
rm(list = ls(all = TRUE)) graphics.off() # some general parameters set.seed(1) # seed for random number generation dt = 1 # length of each time interval T = 250 # time period t = seq(1, T, by = dt) # vector containing time steps r = NULL # vector of instantaneous short rate r[1] = 0.03 # initial value of the short rate dv = NULL # random increment, depending on # the Wiener Process and volatility SFEsimVasicek = function(a, b, sigma) {     # Vasicek Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Vasicek Model") } SFEsimCIR = function(a, b, sigma) {     # Cox-Ingersoll-Ross Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * sqrt(r[i - 1]) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + a * (b - r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Cox-Ingersoll-Ross Model") } delta = function(t) {     # Deterministic function of Time     delta = 0.0000644 * t     return(delta) } SFEsimHullWhite = function(a, sigma) {     # Hull-White Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + (delta(t = i - 1) - a * r[i - 1]) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Hull White Model") } SFEsimHoLee = function(sigma) {     # Ho-Lee Short Rate Model     for (i in 2:T) {         dv[i] = sigma * sqrt(dt / T) * rnorm(1, mean = 0, sd = 1)         r[i] = r[i - 1] + delta(i - 1) * (dt / T) + dv[i]     }     plot(t, r, type = "l", col = "blue", xlab = "Time", ylab = "Instantaneous Short Rate",        main = "Simulation of a One Factor Short-Rate Model         \n Ho Lee Model") } par(mfrow = c(2, 2)) SFEsimVasicek(a = 0.161, b = 0.014, sigma = 0.009) SFEsimCIR(a = 0.221, b = 0.02, sigma = 0.055) SFEsimHullWhite(a = 0.161, sigma = 0.009) SFEsimHoLee(sigma = 0.009)
source("E:/Work/Practice/R/RProject1/RProject1/crr/hoo-lee.R", echo = TRUE, encoding = "Windows-1252")
